"""
Authentication setup utility for Taiga MCP Bridge.

Helps users generate .env file with authentication tokens.
"""

import getpass
import sys
from pathlib import Path

import httpx


def login_and_get_token(api_url: str, username: str, password: str) -> dict:
    """
    Login to Taiga and get authentication token.

    Args:
        api_url: Taiga API URL (e.g., https://api.taiga.io)
        username: Taiga username
        password: Taiga password

    Returns:
        Dictionary with auth_token and user info

    Raises:
        httpx.HTTPError: If authentication fails
    """
    # Ensure API URL doesn't end with /api/v1
    api_url = api_url.rstrip("/")
    if api_url.endswith("/api/v1"):
        api_url = api_url[:-7]

    login_url = f"{api_url}/api/v1/auth"

    with httpx.Client(timeout=30.0) as client:
        response = client.post(
            login_url,
            json={"type": "normal", "username": username, "password": password},
            headers={"Content-Type": "application/json"},
        )
        response.raise_for_status()
        return response.json()


def create_env_file(api_url: str, auth_token: str, env_path: Path) -> None:
    """
    Create or update .env file with authentication details.

    Args:
        api_url: Taiga API URL
        auth_token: Authentication token
        env_path: Path to .env file
    """
    # Ensure API URL has /api/v1 suffix
    api_url = api_url.rstrip("/")
    if not api_url.endswith("/api/v1"):
        api_url = f"{api_url}/api/v1"

    content = f"""# Taiga MCP Bridge Configuration
# Generated by: pytaiga-mcp login

# Taiga API Configuration
TAIGA_API_URL={api_url}
TAIGA_AUTH_TOKEN={auth_token}
TAIGA_TOKEN_TYPE=Bearer

# Server Configuration
TAIGA_TRANSPORT=stdio
LOG_LEVEL=INFO

# Optional: Uncomment to customize
# SESSION_EXPIRY=28800
# REQUEST_TIMEOUT=30
# MAX_CONNECTIONS=10
# RATE_LIMIT_REQUESTS=100
"""

    env_path.write_text(content)


def interactive_login() -> None:
    """
    Interactive login process to generate .env file.
    """
    print("=" * 70)
    print("Taiga MCP Bridge - Authentication Setup")
    print("=" * 70)
    print()
    print("This will help you generate a .env file with your Taiga credentials.")
    print()

    # Get Taiga instance URL
    print("Enter your Taiga instance URL:")
    print("  Examples:")
    print("    - https://api.taiga.io (for cloud)")
    print("    - http://localhost:9000 (for local)")
    api_url = input("Taiga URL [https://api.taiga.io]: ").strip()

    if not api_url:
        api_url = "https://api.taiga.io"
        print(f"Using default: {api_url}")

    # Get credentials
    print()
    username = input("Username: ").strip()
    if not username:
        print("\nError: Username is required", file=sys.stderr)
        sys.exit(1)

    password = getpass.getpass("Password: ")
    if not password:
        print("\nError: Password is required", file=sys.stderr)
        sys.exit(1)

    # Authenticate
    print()
    print("Authenticating with Taiga...")

    try:
        auth_data = login_and_get_token(api_url, username, password)
        auth_token = auth_data.get("auth_token")

        if not auth_token:
            print("\nError: No auth token received from Taiga", file=sys.stderr)
            sys.exit(1)

        # Create .env file
        env_path = Path(".env")
        create_env_file(api_url, auth_token, env_path)

        print("\n✓ Authentication successful!")
        print(f"✓ Created {env_path.absolute()}")
        print()
        print("You can now run: poetry run pytaiga-mcp")
        print()
        print("Note: This token will expire after 8 hours (default).")
        print("      Run 'pytaiga-mcp login' again to refresh it.")
        print()

    except httpx.HTTPStatusError as e:
        print(f"\n✗ Authentication failed: {e.response.status_code}", file=sys.stderr)
        if e.response.status_code == 400:
            print(
                "  Invalid credentials. Please check your username and password.", file=sys.stderr
            )
        else:
            print(f"  {e.response.text}", file=sys.stderr)
        sys.exit(1)
    except httpx.HTTPError as e:
        print(f"\n✗ Network error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"\n✗ Unexpected error: {e}", file=sys.stderr)
        sys.exit(1)


def interactive_login_to_cache(host: str) -> tuple[str, int] | None:
    """
    Interactive login process that returns token for caching.

    Args:
        host: Taiga host URL

    Returns:
        Tuple of (auth_token, user_id) or None if failed
    """
    print("=" * 70)
    print("Taiga MCP Bridge - Interactive Authentication")
    print("=" * 70)
    print()
    print(f"Host: {host}")
    print()

    # Get credentials
    username = input("Username: ").strip()
    if not username:
        print("\nError: Username is required", file=sys.stderr)
        return None

    password = getpass.getpass("Password: ")
    if not password:
        print("\nError: Password is required", file=sys.stderr)
        return None

    # Authenticate
    print()
    print("Authenticating with Taiga...")

    try:
        auth_data = login_and_get_token(host, username, password)
        auth_token = auth_data.get("auth_token")
        user_id = auth_data.get("id")

        if not auth_token:
            print("\nError: No auth token received from Taiga", file=sys.stderr)
            return None

        print("\n✓ Authentication successful!")
        return (auth_token, user_id)

    except httpx.HTTPStatusError as e:
        print(f"\n✗ Authentication failed: {e.response.status_code}", file=sys.stderr)
        if e.response.status_code == 400:
            print(
                "  Invalid credentials. Please check your username and password.", file=sys.stderr
            )
        else:
            print(f"  {e.response.text}", file=sys.stderr)
        return None
    except httpx.HTTPError as e:
        print(f"\n✗ Network error: {e}", file=sys.stderr)
        return None
    except Exception as e:
        print(f"\n✗ Unexpected error: {e}", file=sys.stderr)
        return None
